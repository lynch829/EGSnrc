<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EGSnrc C++ class library: Geometry module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">EGSnrc C++ class library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<h1>Geometry module</h1>  </div>
</div>
<div class="contents">

<p>This module contains classes that model various geometry types. If you are looking for description of how to define a certain geometry in your input file, click on the corresponding class and see the detailed description.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlabel.html">label</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Base geometry class. Every geometry class must be derived from <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a>.  <a href="classlabel.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Box.html">EGS_Box</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A box geometry.  <a href="classEGS__Box.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__CDGeometry.html">EGS_CDGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A "combinatorial dimension" geometry.  <a href="classEGS__CDGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__SimpleCone.html">EGS_SimpleCone</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A single cone that may be open (i.e. extends to infinity or closed by a plane perpendicular to the cone axis.  <a href="classEGS__SimpleCone.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ParallelCones.html">EGS_ParallelCones</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of "parallel cones" (<em>i.e</em>. cones with the same axis and opening angles but different apexes)  <a href="classEGS__ParallelCones.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ConeSet.html">EGS_ConeSet</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of cones with different opening angles but the same axis and apexes.  <a href="classEGS__ConeSet.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__ConeStack.html">EGS_ConeStack</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A cone stack.  <a href="classEGS__ConeStack.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__CylindersT.html">EGS_CylindersT&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric cylinders.  <a href="classEGS__CylindersT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__EllipticCylindersT.html">EGS_EllipticCylindersT&lt; Tx, Ty &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric elliptic cylinders.  <a href="classEGS__EllipticCylindersT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__EnvelopeGeometry.html">EGS_EnvelopeGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An envelope geometry class.  <a href="classEGS__EnvelopeGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__FastEnvelope.html">EGS_FastEnvelope</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An envelope geometry class.  <a href="classEGS__FastEnvelope.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__StackGeometry.html">EGS_StackGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A stack of geometries.  <a href="classEGS__StackGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__TransformedGeometry.html">EGS_TransformedGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A transformed geometry.  <a href="classEGS__TransformedGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__IPlanes.html">EGS_IPlanes</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of planes intersecting in the same axis.  <a href="classEGS__IPlanes.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__RadialRepeater.html">EGS_RadialRepeater</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A radial geometry replicator.  <a href="classEGS__RadialRepeater.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__NDGeometry.html">EGS_NDGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class modeling a N-dimensional geometry.  <a href="classEGS__NDGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__XYZGeometry.html">EGS_XYZGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An XYZ-geometry.  <a href="classEGS__XYZGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__DeformedXYZ.html">EGS_DeformedXYZ</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A deformed XYZ-geometry.  <a href="classEGS__DeformedXYZ.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__XYZRepeater.html">EGS_XYZRepeater</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry repeated on a regular XYZ grid.  <a href="classEGS__XYZRepeater.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Octree.html">EGS_Octree</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An octree geometryThe <a class="el" href="classEGS__Octree.html" title="An octree geometryThe EGS_Octree class implements an octree geometry. An octree is a partitioning sch...">EGS_Octree</a> class implements an octree geometry. An octree is a partitioning scheme for a 3D volume where cells are subdivided into 8 children cells (corresponding to the 8 octants making up the parent cell). Octrees are useful to partition space in multi-resolution fashion: portion of space requiring more details are further subdivided as needed.  <a href="classEGS__Octree.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PlanesT.html">EGS_PlanesT&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of parallel planes.  <a href="classEGS__PlanesT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PlaneCollection.html">EGS_PlaneCollection</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of non-parallel planes.  <a href="classEGS__PlaneCollection.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PrismT.html">EGS_PrismT&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for modeling prisms.  <a href="classEGS__PrismT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__PyramidT.html">EGS_PyramidT&lt; T &gt;</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A template class for modeling pyramids.  <a href="classEGS__PyramidT.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__Space.html">EGS_Space</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The entire space as a geometry object.  <a href="classEGS__Space.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__cSpheres.html">EGS_cSpheres</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of concentric spheres.  <a href="classEGS__cSpheres.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__UnionGeometry.html">EGS_UnionGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A geometry constructed as the union of other geometries.  <a href="classEGS__UnionGeometry.html#_details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEGS__VHPGeometry.html">EGS_VHPGeometry</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A Voxelized Human Phantom (VHP) geometry.  <a href="classEGS__VHPGeometry.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="groups"></a>
Modules</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ElementaryG.html">Elementary Geometries</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>"Elementary" or "primitive" geometries are geometry classes that implement their methods directly (<em>i.e</em>. without the help of other geometries). </p>
<br/></td></tr>
</p>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CompositeG.html">Composite Geometries</a></td></tr>

<p><tr><td class="mdescLeft">&#160;</td><td class="mdescRight"><p>Composite geometries are classes that implement their geometry methods using the geometry methods of their constituent geometries based on a certain type of logic. </p>
<br/></td></tr>
</p>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This module contains classes that model various geometry types. If you are looking for description of how to define a certain geometry in your input file, click on the corresponding class and see the detailed description. </p>
<p><a class="anchor" id="geometry_anchor"></a></p>
<p><a class="el" href="group__Geometry.html#geometry_general">General discussion</a><br/>
 <a class="el" href="group__Geometry.html#geometry_design">Design of the egspp geometry package</a><br/>
 <a class="el" href="group__Geometry.html#geometry_common">Common geometry input syntax</a><br/>
 <a class="el" href="group__Geometry.html#geometry_media">Media definition</a><br/>
 <a class="el" href="group__Geometry.html#geometry_implementing">Implementing new geometry classes</a><br/>
 <a class="el" href="group__Geometry.html#geometry_view">The geometry viewer</a><br/>
 <a class="el" href="group__Geometry.html#geometry_examples">Example geometries</a><br/>
</p>
<h2><a class="anchor" id="geometry_general"></a>
General discussion</h2>
<p>There are many different ways to model a geometrical structure. One frequently used approach is to use simple solids such as boxes, spheres, cylinders, etc., and various boolean operations (unions, logical or, etc.) to put together more complicated objects (this approach is typically known as constructive solid geometry, CGS). Another way is to describe geometrical objects using the surfaces by which they are surrounded. In many cases first and second order surfaces or a limited set of relatively simple solids are sufficient to describe a wide range of even complex objects and therefore, at least in principle, these two approaches reduce the task of programming a general purpose geometry package to the programming of a relatively small number of geometrical methods. However, in practical simulations the region number of a particle must be known at all times and determining the index of a new region being entered may not be a trivial task. Many of the available geometry packages solve this problem by initiating a global search for the new region index, which makes the simulation extremely slow in situations with complex geometries and a large number of regions. For instance, it is well known that a MCNP simulation in a simple voxel-type geometry constructed from the MCNP geometry package is of the order of 1000 times slower compared to a special-purpose voxel geometry. An efficient way of crossing interfaces between different regions has therefore been given a high priority in the design and implementation of the EGSnrc geometry package.</p>
<p>The EGSnrc geometry package considers geometrical structures at the highest possible level of abstraction: any object that is able to provide a certain set of geometry related methods is considered to be a "geometry". No distinction is made between surfaces or solids, or between simple geometrical structures and highly complex ones. An object is considered to be a geometry if it can provide answers to the following questions:</p>
<ol type="1">
<li>Given a region index <img class="formulaInl" alt="$i$" src="form_0.png"/>, a position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png"/>, a direction <img class="formulaInl" alt="$\vec{u}$" src="form_2.png"/> and an intended transport distance <img class="formulaInl" alt="$t$" src="form_3.png"/>, will the particle trajectory intersect a boundary? If yes, what is the new region index and what is the distance to the boundary? The method providing the answer to this questions will be referred to as the <code>howfar()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a42a459b557011291ea2e8978ebee6295">howfar() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
<li>Given a region index <img class="formulaInl" alt="$i$" src="form_0.png"/> and a position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png"/>, what is the nearest distance to a boundary in any direction ? The method providing the answer to this questions will be referred to as the <code>hownear()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a111e6d8ea34e403bebaf3621223950d9">hownear() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
<li>Is position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png"/> inside or outside the geometry. The method providing the answer to this questions will be referred to as the <code>isInside()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#a816bf2d26bdabc3e4ee2f092bd903d92">isInside() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
<li>In addition to the above, what is the region index corresponding to <img class="formulaInl" alt="$\vec{x}$" src="form_1.png"/> if it is inside ? The method providing the answer to this questions will be referred to as the <code>isWhere()</code> method of a geometry and is specified by the <a class="el" href="classEGS__BaseGeometry.html#af1a37ed6f281a2442a7e96d9658894a9">isWhere() </a> pure virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
<li>What is the medium in region <img class="formulaInl" alt="$i$" src="form_0.png"/>? The method providing the answer to this questions will be referred to as the <code>medium()</code> method of a geometry specified by the <a class="el" href="classEGS__BaseGeometry.html#aeae04119c0fa7a94b41627460878bd24">medium() </a> virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
<li>How many regions are there in this geometry? The method providing the answer to this questions will be referred to as the <code>regions()</code> method of a geometry specified by the <a class="el" href="classEGS__BaseGeometry.html#a46c4d27e3c6ca8f8392381c6b4f06df5">regions() </a> virtual function of the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class.</li>
</ol>
<p>As a convention, all geometries numerate their regions between 0 and the number of regions minus one whereas a negative region index is considered to be outside of the geometry (<em>i.e</em>., if a particle would exit the geometry after crossing a boundary, the new region index returned is -1, or if the region index <img class="formulaInl" alt="$i$" src="form_0.png"/> is negative in questions 1 and 2, the geometry object can assume that it is known that the position <img class="formulaInl" alt="$\vec{x}$" src="form_1.png"/> is outside of the geometry). Questions 1 and 2 are specified by the EGSnrc geometry interface specification except that now geometry objects must be able to determine the answer to these questions also for the situation of the position being outside (<em>i.e</em>. region <img class="formulaInl" alt="$i$" src="form_0.png"/> is negative). This extension, together with 3, 4 and 6 is necessary so that one can construct more complicated geometries from simpler geometries as will be seen below. Questions 5 and 7 are necessary to completely decouple the geometry information from EGSnrc (when EGSnrc is compiled for use with the new C++ interface, all arrays present in the original version holding information on a region-by-region bases such as the medium index, the particle transport cutoff energies, etc., are turned into scalar quantities).</p>
<p>To describe the various geometry objects provided by the egspp library, we will group them in two broad classes:</p>
<ol type="1">
<li>Elementary or primitive geometries. These geometries are called elementary not because it is easy to implement the required methods but because these methods are implemented directly, without the use of geometry methods of other objects.</li>
<li>Composite geometries. The geometry methods of such geometries are implemented using the geometry methods of the objects from which such geometries are built using a certain type of logic to obtain <code>howfar()</code>, <code>hownear()</code>, etc., from the corresponding methods of the constituents. Composite geometries can be constructed from elementary geometries and/or other composite geometries.</li>
</ol>
<h2><a class="anchor" id="geometry_design"></a>
Design of the egspp geometry package</h2>
<p>Given the above discussion, all geometry objects in the egspp package are derived from the <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a> class, which is part of the main egspp library. Concrete geometry classes are compiled into separate shared libraries (a.k.a. dynamic shared objects, DSO, or dynamically linkable library, DLL) that can be loaded dynamically at run time as needed. Each of these geometry libraries provides a </p>
<div class="fragment"><pre class="fragment">
EGS_BaseGeometry *createGeometry(EGS_Input *inp)
</pre></div><p> C-style function, the address of which is resolved when a geometry library is loaded and is used to create a geometry object from the input information stored in an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> object and pointed to by <em>inp</em>. The information stored in the input object is typically extracted from an input file that specifies the various aspects of a particle simulation. It is of course possible to create an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> object specifying one or more geometries by other means (<em>e.g</em>. within a GUI) and then use the geometry creation functions <a class="el" href="classEGS__BaseGeometry.html#a7f73df441569e779463ebb17d15a864a" title="Create a geometry (or geometries) from a given input.">EGS_BaseGeometry::createGeometry()</a> or <a class="el" href="classEGS__BaseGeometry.html#a2b5590a407e70597c6da34c1647c6934" title="Create a single geometry from the input inp.">EGS_BaseGeometry::createSingleGeometry()</a> to obtain a pointer to the geometry object.</p>
<p>The motivation behind this design is twofold:</p>
<ul>
<li>Most of the time simulations are performed within a geometry that only requires a single class or a limited set of classes to be modeled. It would therefore be wasteful to link against a library containing all geometry classes available in egspp.</li>
<li>Extendibility: it is easy to create a new geometry class by deriving from <a class="el" href="classEGS__BaseGeometry.html">EGS_BaseGeometry</a>, implementing the necessary methods and the <code>createGeometry</code> function and compiling the class into a shared library that can immediately be used with the rest of the system.</li>
</ul>
<h2><a class="anchor" id="geometry_common"></a>
Common geometry input syntax</h2>
<p>The definition of a geometry must be within a composite property <code>geometry</code> within another composite property <code>geometry definition</code> of the input object. This implies that if the geometry is defined in an input file, the file must contain a section </p>
<div class="fragment"><pre class="fragment">
:start geometry definition:
    :start geometry:
       definition of a geometry
    :stop geometry:
:stop geometry definition:
</pre></div><p> (see the <a class="el" href="classEGS__Input.html">EGS_Input documentation </a> for details of the input file syntax. Note also that in what follows the input file syntax will be used to describe an <a class="el" href="classEGS__Input.html" title="A class for storing information in a tree-like structure of key-value pairs. This class is used throu...">EGS_Input</a> property). If more than one geometry is to be constructed, there can be several <code>geometry</code> properties (<em>i.e</em>. several <code>:start geometry: :stop geometry: </code> sections). Each geometry definition must have a <code>name</code> property with a unique name value because names are used to refer to other geometries in <em>e.g</em>. the construction of composite geometries. Each geometry definition must also contain a <code>library</code> property, which be used to dynamically load the library that provides the geometry class being defined by the input. Library names must be given without their platform specific prefixes and suffixes (<em>e.g</em>. <code>egs_planes</code> stands for <code>libegs_planes.so</code> on Linux and <code>egs_planes.dll</code> on Windows). Some geometry libraries provide implementations for more than one geometry class. Fot such libraries a <code>type</code> property is required in the geometry definition to specify the type of the object being constructed. For instance, </p>
<div class="fragment"><pre class="fragment">
:start geometry:
    library = egs_planes
    type    = EGS_Xplanes
    name    = planes1
    other input
:stop geometry:
</pre></div><p> is needed in the input file to specify that a geometry of type <code>EGS_Xplanes</code> with name <code>planes1</code> should be constructed from the DSO <code>egs_planes</code> (<code>other</code> <code>input</code> stands for additional key-value pairs used by the <code>EGS_Xplanes</code> constructor).</p>
<h3><a class="anchor" id="geometry_media"></a>
Media definition</h3>
<p>All geometries can be filled with media by including a <code>media input</code> property within the the geometry definition. Because geometries can be used as building blocks for other geometries, which could fill the regions with media, it is not considered a mistake if a geometry does not define its media. However, the user must be careful to eventually define media for all real regions of the simulation geometry to avoid program crashes. Many geometries can be filled with media with the following keys within the <code>media input</code> property: </p>
<div class="fragment"><pre class="fragment">
:start media input:
    media = list of media names as in the PEGS file
    set medium = 2 or 3 integers
    set medium = 2 or 3 integers
    ...
    set medium = 2 or 3 integers
:stop media input:
</pre></div><p> The <code>media</code> key defines the media names from the PEGS file that will be used for the simulation. When this key is encountered, all regions of a geometry are filled with the first medium in the list of media. There can be an arbitrary number of <code>set</code> <code>medium</code> keys (including zero, in which case the geometry will be homogeneous and filled with the first medium in the list of media). If 2 integers <img class="formulaInl" alt="$i_1, i$" src="form_4.png"/> are found as input to a <code>set</code> <code>medium</code> key, then region <img class="formulaInl" alt="$i_1$" src="form_5.png"/> is set to contain the medium with index <img class="formulaInl" alt="$i$" src="form_0.png"/> in the list of media. If 3 integers <img class="formulaInl" alt="$i_1, i_2, i$" src="form_6.png"/> are found, then all regions between <img class="formulaInl" alt="$i_1$" src="form_5.png"/> and <img class="formulaInl" alt="$i_2$" src="form_7.png"/> (inclusive) are set to the medium with index <img class="formulaInl" alt="$i$" src="form_0.png"/> in the list of media. It is important to note that the medium index is the index in the list of media for the current geometry, not a global medium index. The geometry factory object, which is responsible for the construction of the various geometries, maintains a global list of media names defined in all geometries and automatically translates local media indices to global media indices. If, for instance, the first geometry defines the media names <code>H2O521ICRU, AL521ICRU, PB521ICRU</code> and the second geometry the media <code>PB521ICRU, H2O521ICRU, W521ICRU</code>, the global list of media after the definition of the second geometry will be <code>H2O521ICRU, AL521ICRU, PB521ICRU, W521ICRU</code>. In the definition of the first geometry one would refer to <code>H2O521ICRU</code> as medium 0, <code>AL521ICRU</code> as medium 1 and to <code>PB521ICRU</code> as medium 2 and they will get translated into global medium indices 0, 1 and 2. In the definition of the second geometry one would refer to <code>PB521ICRU</code> as medium 0, to <code>H2O521ICRU</code> as medium 1 and to <code>W521ICRU</code> as medium 2 and they will get translated into global media 2, 0 and 4. It is important to note that region and medium indices use C-style numbering, <em>i.e</em>. they run between 0 and <img class="formulaInl" alt="$n-1$" src="form_8.png"/> and not between 1 and <img class="formulaInl" alt="$n$" src="form_9.png"/>.</p>
<p>The definition of media according to the above input syntax is performed in the <a class="el" href="classEGS__BaseGeometry.html#a28bf612777de14f97108021ae7eb3865">setMedia() </a> function of the base geometry class. Some geometry classes re-implement this function to either prevent media definition (<em>e.g</em>. <a class="el" href="classEGS__UnionGeometry.html" title="A geometry constructed as the union of other geometries.">EGS_UnionGeometry</a>, where the media definition should be done in each geometry of the union, not the union itself) or to implement a more convenient media definition scheme (<em>e.g</em>. <a class="el" href="classEGS__NDGeometry.html" title="A class modeling a N-dimensional geometry.">EGS_NDGeometry</a> or <a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a>).</p>
<h2><a class="anchor" id="geometry_implementing"></a>
Implementing new geometry classes</h2>
<p>The implementation of a new geometry class may become necessary for various reasons, <em>e.g</em>.</p>
<ol type="1">
<li>The geometrical structure of interest can not be constructed using the classes supplied with the egspp distribution. <a href="EGS__Box-example.html">This page</a> provides a detailed description of the implementation of the <a class="el" href="classEGS__Box.html" title="A box geometry.">EGS_Box</a> class that can serve as a guide for developing a new geometry class.</li>
<li>The user wants to avoid repeating the definition of the same geometry in many input files specifying simulations that involve the same, potentially complex geometry. <a href="geometry_2example1_2geometry__example1_8cpp-example.html">This page</a> shows how to implement a geometry DSO using existing geometry classes for the sake of reducing or eliminating input required to define a geometry. An alternative implementation is found <a href="geometry_2example2_2geometry__example2_8cpp-example.html">here.</a></li>
<li>The user may want to re-implement some method of an existing geometry class such as <em>e.g</em>. <a class="el" href="classEGS__BaseGeometry.html#a28bf612777de14f97108021ae7eb3865">setMedia() </a> to make the definition of media easier</li>
</ol>
<p>The geometry testing <a class="el" href="classEGS__GeometryTester.html">utility </a> provided with the distribution is very helpful in the process of developing new geometries and has helped to find numerous bugs in the initial implementations of the various geometry classes provided with <code>egspp</code>.</p>
<h2><a class="anchor" id="geometry_view"></a>
The geometry viewer</h2>
<p>The geometry package comes with a viewer that can be used to look at a geometry defined in an input file in 3D. The viewer permits the user to zoom in and out, change the viewing position, change the colors of the various materials, make materials (semi-)transparent so that it is possible to see inside the geometry, etc. To view the geometry defined in the file <code>some_file</code>, execute the following command </p>
<div class="fragment"><pre class="fragment">
egs_view some_file
</pre></div><p> If the name of the file is omitted (or the viewer is started by clicking on its icon), the user is prompted to select a geometry definition file from a file selection dialog. After reading the geometry information, the geometry viewer attempts to automatically determine an optimum viewing position and zoom factor. This is done by first searching for a point that is inside the geometry and then sending out rays in all directions to check for the size of the geometry being viewed. The search for a point inside the geometry is done by default within a box of 100x100x100 about the origin using a step size of 1. If your geometry is outside of this box or if it is too small to be resolved by the search grid, the viewer will fail to find a point inside the geometry and will display an error message. If this problem occurs, one has to include the following section in the geometry definition file outside of the geometry definition section: </p>
<div class="fragment"><pre class="fragment">
:start view control:
    xmin = some input
    xmax = some input
    ymin = some input
    ymax = some input
    zmin = some input
    zmax = some input
:stop view control:
</pre></div><p> to help the viewer find a point inside the geometry. Here, <code> xmin, xmax, ...</code> define the box in which it is searched for an inside point.</p>
<p>The rendering of the 3D scene is done using the same geometry methods that are used in a particle simulation (<a class="el" href="classEGS__BaseGeometry.html#a42a459b557011291ea2e8978ebee6295">howfar()</a>, <a class="el" href="classEGS__BaseGeometry.html#af1a37ed6f281a2442a7e96d9658894a9">isWhere()</a>, etc.) by sending rays from the viewing position to the projection screen and calculating their intersections with the geometry. Although this approach is much slower than rendering a scene built from GL primitives and therefore requires a fairly fast CPU, it has the advantage of a thorough check of the geometry definition. If the scene rendered by the viewer looks OK and corresponds to what the user expects, the user can be fairly confident that the geometry definition has no mistakes.</p>
<div align="center">
<img src="view_controls.png" alt="view_controls.png"/>
<p><strong>Geometry viewer controls</strong></p></div>
<p>Most of the controls of the viewer should be intuitive except for the definition of clipping planes. By using one or more clipping planes one can remove portions of the geometry (everything between the plane and the viewing position is ignored), which may be helpful for viewing the inside regions of a geometry, viewing only portions of a geometry using a larger zoom factor, etc. To define a clipping plane, click on the <code>More</code>... button. This will show an additional dialog containing a table. </p>
<div align="center">
<img src="clipping.png" alt="clipping.png"/>
<p><strong>Defining clipping planes</strong></p></div>
<p>The four columns of the table define the x-, y- and z-components of the clipping plane normal and the clipping plane position <img class="formulaInl" alt="$d$" src="form_10.png"/> (so that all points on the plane satisfy the equation <img class="formulaInl" alt="$a_x x + a_y y + a_z z = d$" src="form_11.png"/>). Up to 10 clipping planes can be defined simultaneously. To also activate a clipping plane, you must select the left-most column containing the clipping plane number by clicking on it and then clicking on the <code>Apply</code> button below the table. To activate several clipping planes at once, hold down the shift key while selecting a plane row from the table.</p>
<p>The 3D image just shown in the viewing window can be saved in a file in any format supported by the Qt library (typically jpeg, png, bmp, and various others) by clicking on the <code>Save</code> <code>image</code> button.</p>
<h2><a class="anchor" id="geometry_examples"></a>
Example geometries</h2>
<p>In the directory <code>$HEN_HOUSE/egs++/geometry/examples</code> there are several example input files specifying geometries for the <code>egspp</code> geometry package. They are provided with the hope that they will help the user to understand the concepts and learn the syntax of the geometry package. Here is a brief description of the examples and screen shots for some of them:</p>
<ul>
<li>The file <code>hemisphere.geom</code> defines a hemisphere using an <a class="el" href="classEGS__NDGeometry.html">N-dimensional </a> geometry made of a <a class="el" href="classEGS__cSpheres.html">set of spheres</a> and a <a class="el" href="classEGS__PlanesT.html">set of planes</a>.</li>
<li>The file <code>pyramid.geom</code> defines a <a class="el" href="classEGS__PyramidT.html">pyramid </a> with an irregular base that is truncated at the two ends with a <a class="el" href="classEGS__PlanesT.html">set of planes </a> within an <a class="el" href="classEGS__NDGeometry.html">N-dimensional geometry</a>.</li>
<li>The file <code>rz.geom</code> defines a RZ-geometry using an <a class="el" href="classEGS__NDGeometry.html">N-dimensional geometry</a> made of a <a class="el" href="classEGS__CylindersT.html">set of cylinders</a> and a <a class="el" href="classEGS__PlanesT.html">set of planes</a>. The geometry defined is the same as in the <code>cavrznrc_template.egsinp</code> file for the CAVRZnrc user code (a simple pancake ionization chamber with graphite walls and air cavity).</li>
<li>The file <code>rz1.geom</code> defines the same geometry as <code>rz.geom</code> but now using an <a class="el" href="classEGS__EnvelopeGeometry.html">envelope geometry</a> to inscribe a smaller cylinder into a larger one, where both cylinders are made using <a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a> objects.</li>
<li>The file <code>cones.geom</code> demonstrates the use of the <a class="el" href="classEGS__ConeSet.html" title="A set of cones with different opening angles but the same axis and apexes.">EGS_ConeSet</a> class. The user is encouraged to change the <code>flag</code> setting to see how this changes the geometry. <div align="center">
<img src="cones.png" alt="cones.png"/>
<p><strong>The cone geometry defined in cones.geom</strong></p></div>
</li>
<li>The file <code>rz_phi.geom</code> shows the use of <a class="el" href="classEGS__IPlanes.html">I-planes </a> to divide a cylinder into azimuthal segments <div align="center">
<img src="iplanes.png" alt="iplanes.png"/>
<p><strong>rz_phi.geom: using I-planes to divide a cylinder into segments</strong></p></div>
</li>
<li>The file <code>xyz.geom</code> defines an <a class="el" href="classEGS__XYZGeometry.html">XYZ-geometry </a> filled with water and two inhomogeneities made of air and aluminum.</li>
<li><code>mushroom.geom</code> defines a mushroom-like geometrical structure using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry </a> with a <a class="el" href="classEGS__PlanesT.html">set of planes</a> as a base and <a class="el" href="classEGS__cSpheres.html">spheres</a> and <a class="el" href="classEGS__CylindersT.html">cylinders </a> inscribed into the two regions defined by the planes.</li>
<li>The file <code>I6702.inp</code> defines a <img class="formulaInl" alt="$^{125}$" src="form_12.png"/>I model 6702 brachytherapy seed using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry</a>, <a class="el" href="classEGS__cSpheres.html">sets of spheres</a> for the rounded ends and an <a class="el" href="classEGS__EnvelopeGeometry.html">envelope </a> containing the radioactive seeds for the middle portion <div align="center">
<img src="I6702.png" alt="I6702.png"/>
<p><strong>Model 6702 brachytherapy seed defined in I6702.inp</strong></p></div>
 <div align="center">
<img src="I6702a.png" alt="I6702a.png"/>
<p><strong>Model 6702 brachytherapy seed defined in I6702.inp</strong></p></div>
 The two different views were generated using the transparency and clipping planes features of the geometry viewer.</li>
<li>The file <code>rounded_ionchamber.geom</code> defines an ionization chamber geometry that has rounded ends using a <a class="el" href="classEGS__CDGeometry.html">CD-geometry</a> <div align="center">
<img src="chamber.png" alt="chamber.png"/>
<p><strong>An ionization chamber with rounded ends defined in rounded_ionchamber.geom</strong></p></div>
</li>
<li>The file <code>chambers_in_box.geom</code> takes the ion chamber described in <code>rounded_ionchamber.geom</code> and inscribes it, together with two transformed replicas, into a box of water using an envelope geometry (see the title page).</li>
<li>The files <code>seeds_in_xyz.geom</code> and <code>seeds_in_xyz1.geom</code> define an XYZ-geometry containing 12 replicas of the brachytherapy seed specified in <code>I6702.inp</code>. The difference between the two is that in the one case the XYZ-geometry is used as the envelope in an envelope geometry whereas in the other case the XYZ-geometry is used as the base geometry of a CD-geometry. The user will quickly notice that the CD-geometry approach is substantially more efficient when trying to view these geometries with the geometry viewer.</li>
<li>The file <code>car.geom</code> shows how to put together a car from simpler structures (<a class="el" href="classEGS__ConeStack.html" title="A cone stack.">EGS_ConeStack</a> objects are used for the axis and wheels, <a class="el" href="classEGS__Box.html">boxes</a> for the car body) using a <a class="el" href="classEGS__UnionGeometry.html">union</a>. <div align="center">
<img src="car.png" alt="car.png"/>
<p><strong>A car geometry defined in car.png</strong></p></div>
</li>
<li>The file <code>photon_linac.geom</code> shows how one can quickly put together a geometry model of the treatment head of a medical linear accelerator. The geometry defined in this file is identical to the 16 MV photon example that comes with the BEAMnrc distribution (except that the monitor chamber is not included). <div align="center">
<img src="linac1.png" alt="linac1.png"/>
<p><strong>A Linac geometry defined in photon_linac.geom</strong></p></div>
 <div align="center">
<img src="linac2.png" alt="linac2.png"/>
<p><strong>A different view of the geometry defined in photon_linac.geom</strong></p></div>
</li>
</ul>
<p>Note that all figures shown in this section were generated with the <code>egspp</code> <a class="el" href="group__Geometry.html#geometry_view">geometry viewer</a>. A more detailed description of the example geometries can be found <a class="el" href="example_geometries.html">here</a>. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
